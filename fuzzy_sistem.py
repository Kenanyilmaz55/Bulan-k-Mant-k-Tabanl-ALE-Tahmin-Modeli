# -*- coding: utf-8 -*-
"""Untitled21.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sf5S7dWLLGSXGSjYoQy_gJb9bafyW97d
"""

import numpy as np
import pandas as pd
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import matplotlib.pyplot as plt

# 1) Veri setini yükle ve ansaliz et
df = pd.read_csv("veri.csv")
print("=== VERİ ANALİZİ ===")
print("Veri seti boyutu:", df.shape)
print("\nDeğişkenlerin istatistikleri:")
print(df.describe())
# 2 üstündeki ale değerlerini sutundan çıkar
df = df[df['ale'] < 2]
print("\nDeğişkenler arası korelasyon (ALE ile):")
correlations = df.corr()['ale'].drop('ale').sort_values(key=abs, ascending=False)
print(correlations)

# 2) Üyelik fonksiyonları
def triangular(x, a, b, c):
    """Üçgen üyelik fonksiyonu"""
    return np.maximum(np.minimum((x - a) / (b - a + 1e-9), (c - x) / (c - b + 1e-9)), 0)

def gaussian(x, mu, sigma):
    """Gauss üyelik fonksiyonu"""
    return np.exp(-((x - mu) ** 2) / (2 * sigma ** 2))

def trapezoidal(x, a, b, c, d):
    """Yamuk üyelik fonksiyonu"""
    return np.maximum(np.minimum(np.minimum((x - a) / (b - a + 1e-9), 1), (d - x) / (d - c + 1e-9)), 0)

# 3) Veri analizi sonuçlarına göre özelleştirilmiş üyelik fonksiyonları

# VERİ ANALİZİ SONUÇLARI:
# anchor_ratio: 10-30 arası, çoğu 15-30 arasında
# trans_range: 12-25 arası, çoğu 15-20 arasında
# node_density: 100, 200, 300 değerleri (kategorik gibi)
# iterations: 14-100 arası, geniş dağılım
# ale: 0.39-2.57 arası, ortalama ~1.0
optimized_triangular = {
    "anchor_ratio": {
        "low":    lambda x: triangular(x, 7.0, 15.0, 18.0),
        "medium": lambda x: triangular(x, 15.0, 18.0, 30.0),
        "high":   lambda x: triangular(x, 18.0, 30.0, 33.0),
    },  # sharp_trapezoidal - sharp_trapezoidal seçildi
    "trans_range": {
        "low":    lambda x: triangular(x, 10.1, 15.0, 17.0),
        "medium": lambda x: triangular(x, 15.0, 17.0, 20.0),
        "high":   lambda x: triangular(x, 17.0, 20.0, 26.9),
    },  # sharp_trapezoidal - sharp_trapezoidal seçildi
    "node_density": {
        "low":    lambda x: triangular(x, 70.0, 100.0, 200.0),
        "medium": lambda x: triangular(x, 100.0, 200.0, 300.0),
        "high":   lambda x: triangular(x, 200.0, 300.0, 330.0),
    },  # sharp_trapezoidal - sharp_trapezoidal seçildi
    "iterations": {
        "low":    lambda x: triangular(x, 1.1, 30.0, 40.0),
        "medium": lambda x: triangular(x, 30.0, 40.0, 70.0),
        "high":   lambda x: triangular(x, 40.0, 70.0, 112.9),
    },  # sharp_trapezoidal - sharp_trapezoidal seçildi


    "ale": {
        "low": lambda x: triangular(x, 0.2, 0.7, 0.9),
        "medium": lambda x: triangular(x, 0.9, 1.2, 1.6),
        "high": lambda x: triangular(x, 1.3, 2.1, 3),
    },
}

# Optimized Gaussian Membership Functions
optimized_gaussian = {
    "anchor_ratio": {
        "low": lambda x: gaussian(x, 14.6, 1.0),
        "medium": lambda x: gaussian(x, 20.0, 1.1),
        "high": lambda x: gaussian(x, 29.6, 1.5),
    },
    "trans_range": {
        "low": lambda x: gaussian(x, 15.3, 0.9),
        "medium": lambda x: gaussian(x, 19.7, 0.7),
        "high": lambda x: gaussian(x, 24.0, 1.0),
    },
    "node_density": {
        "low":    lambda x: triangular(x, 70.0, 100.0, 200.0),
        "medium": lambda x: triangular(x, 100.0, 200.0, 300.0),
        "high":   lambda x: triangular(x, 200.0, 300.0, 330.0),
    },  # sharp_trapezoidal - sharp_trapezoidal seçildi
    "iterations": {
        "low": lambda x: gaussian(x, 23.9, 7.8),
        "medium": lambda x: gaussian(x, 48.6, 10.8),
        "high": lambda x: gaussian(x, 81.7, 6.0),
    },
    "ale": {
        "low": lambda x: gaussian(x, 0.7, 0.2),
        "medium": lambda x: gaussian(x, 1.2, 0.3),
        "high": lambda x: gaussian(x, 1.8, 0.4),
    },
}
# Hibrit model - daha iyi performans için
hybrid_optimized = {
   "anchor_ratio": {
    "low": lambda x: gaussian(x, 14.0, 1.2),      # Ana yoğunluk bölgesi 13-15
    "medium": lambda x: triangular(x, 16.0, 20.0, 26.0),  # Orta bölge geniş tutuldu
    "high": lambda x: gaussian(x, 29.0, 1.0),     # Yoğunluk 28-30'da
    },
    "trans_range": {
    "low": lambda x: trapezoidal(x, 12.2, 13.8, 15.2, 16.8),   # Sol cluster
    "medium": lambda x: triangular(x, 16.5, 18.5, 20.5),       # Orta geçiş
    "high": lambda x: trapezoidal(x, 20.0, 22.0, 23.5, 24.8),  # Sağ cluster
    },
    "node_density": {
      "low": lambda x: trapezoidal(x, 80, 90, 110, 120),
      "medium": lambda x: trapezoidal(x, 180, 190, 210, 220),
      "high": lambda x: trapezoidal(x, 280, 290, 310, 320),

    },
    "iterations": {
        "low": lambda x: trapezoidal(x, 5.4, 21.5, 26.3, 36.3),
        "medium": lambda x: trapezoidal(x, 36.3, 43.8, 53.5, 65.2),
        "high": lambda x: trapezoidal(x, 65.2, 73.6, 89.9, 108.6),
    },
    "ale": {
        "low": lambda x: gaussian(x, 0.7, 0.2),
        "medium": lambda x: gaussian(x, 1.2, 0.3),
        "high": lambda x: gaussian(x, 1.6, 0.09),
    },

}
optimized_trapezoidal = {
    "anchor_ratio": {
        "low": lambda x: trapezoidal(x, 8.0, 13.2, 16.1, 17.3),
        "medium": lambda x: trapezoidal(x, 17.3, 18.0, 22.0, 24.8),
        "high": lambda x: trapezoidal(x, 24.8, 26.6, 32.5, 32.0),
    },
    "trans_range": {
        "low": lambda x: trapezoidal(x, 10.7, 13.8, 16.8, 17.5),
        "medium": lambda x: trapezoidal(x, 17.5, 17.7, 21.7, 21.8),
        "high": lambda x: trapezoidal(x, 21.8, 21.6, 26.4, 26.3),
    },
    "node_density": {
        "low": lambda x: trapezoidal(x, 80.0, 90.0, 110.0, 150.0),
        "medium": lambda x: trapezoidal(x, 150.0, 180.0, 220.0, 250.0),
        "high": lambda x: trapezoidal(x, 250.0, 270.0, 330.0, 320.0),
    },
    "iterations": {
        "low": lambda x: trapezoidal(x, 5.4, 21.5, 26.3, 36.3),
        "medium": lambda x: trapezoidal(x, 36.3, 43.8, 53.5, 65.2),
        "high": lambda x: trapezoidal(x, 65.2, 73.6, 89.9, 108.6),
    },
    "ale": {
        "low": lambda x: trapezoidal(x, 0.2, 0.6, 0.8, 0.9),
        "medium": lambda x: trapezoidal(x, 0.9, 1.1, 1.3, 1.6),
        "high": lambda x: trapezoidal(x, 1.6, 1.8, 2.3, 2.8),
    },
}
# ALE çıkış değerleri - veri analizi sonuçlarına göre

ale_centers = {"low": 0.5, "medium": 1.3, "high": 2.4}

ale_x = np.linspace(0.35, 2.6, 300)


# ALE çıkış değerleri - veri analizi sonuçlarına göre

# 4) Geliştirilmiş kural tabanı - korelasyon analizi sonuçlarına göre
# Korelasyon sonuçları:
# iterations ile ALE arasında negatif korelasyon (-0.46) - güçlü
# anchor_ratio ile ALE arasında negatif korelasyon (-0.35) - orta
# node_density ile ALE arasında negatif korelasyon (-0.30) - orta
# trans_range ile ALE arasında pozitif korelasyon (0.44) - güçlü
enhanced_rules = [
    ({"node_density": "low", "iterations" : "low"}, "high", 5),
    ({"node_density": "low"}, "high", 2.3), # daha güçlü kural
    ({"node_density": "medium"}, "low", 1.2),
    ({"node_density": "high"}, "low", 2.5),
    ({"iterations": "low"}, "high", 1.5),   # daha etkili
    ({"iterations": "medium"}, "low", 1.0),
    ({"iterations": "high"}, "low", 2.5),
    ({"anchor_ratio": "high"}, "low", 2.5),  # önemli
    ({"anchor_ratio": "medium"}, "low", 1.0),
    ({"trans_range": "medium"}, "low", 1.0),
    ({"trans_range": "high"}, "low", 1.0),

    ({"anchor_ratio": "high", "node_density": "high"}, "low", 5.0),
    ({"iterations": "high", "node_density": "high"}, "low", 2.0),
    ({"iterations": "low", "node_density": "low"}, "high", 2.0),
    ({"anchor_ratio": "high", "trans_range": "high"}, "low", 1.0),
        # Kombine kurallar - yeni değişkenlerle
     ({"anchor_ratio": "low", "trans_range": "low"}, "low", 1.0),
    ({"anchor_ratio": "low", "trans_range": "medium"}, "high", 1.0),
    ({"anchor_ratio": "low", "anchor_ratio": "medium"}, "high", 1.0),

    #({}, "medium", 0.1),  # varsayılan kuralın etkisi azaltıldı
]
# 5) Geliştirilmiş defuzzification yöntemleri
def defuzz_centroid(activations, ale_mf_dict):
    """Ağırlık merkezi yöntemi"""
    agg = np.zeros_like(ale_x)
    for term, act in activations.items():
        if act > 0:
            mf_vals = ale_mf_dict[term](ale_x)
            agg = np.maximum(agg, np.minimum(act, mf_vals))

    if agg.sum() == 0:
        return 1.2
    return np.sum(ale_x * agg) / agg.sum()

def defuzz_weighted_average(activations):
    """Ağırlıklı ortalama yöntemi"""
    if not activations or sum(activations.values()) == 0:
        return 1.2

    num = sum(act * ale_centers[term] for term, act in activations.items() if act > 0)
    den = sum(act for act in activations.values() if act > 0)
    return num / den

def defuzz_center_of_sums(activations, ale_mf_dict):
    agg = np.zeros_like(ale_x)
    for term, act in activations.items():
        if act > 0:
            agg += ale_mf_dict[term](ale_x) * act
    if agg.sum() == 0:
        return 1.2
    return np.sum(ale_x * agg) / agg.sum()

def defuzz_max_membership(activations):
    """Maksimum üyelik yöntemi"""
    if not activations:
        return 1.2
    max_term = max(activations.items(), key=lambda x: x[1])
    return ale_centers[max_term[0]]

# 6) Tek satır değerlendirme fonksiyonu
def evaluate_row(row, mfs, method, aggregation="max"):
    rule_strengths = []
    rule_terms = []
    rule_weights = []

    for antecedents, consequent, weight in enhanced_rules:
        if not antecedents:  # default rule
            strength = 0.1
        else:
            if aggregation == "min":
                strength = min(mfs[var][setname](row[var]) for var, setname in antecedents.items())
            elif aggregation == "prod":
                strength = np.prod([mfs[var][setname](row[var]) for var, setname in antecedents.items()])
            else:  # default to max (actually still using min logic)
                strength = min(mfs[var][setname](row[var]) for var, setname in antecedents.items())

        weighted_strength = strength * weight
        rule_strengths.append(weighted_strength)
        rule_terms.append(consequent)

    # Aktivasyonları hesapla
    activations = {}
    for strength, term in zip(rule_strengths, rule_terms):
        if strength > 0:
            activations[term] = max(activations.get(term, 0), strength)

    # Defuzzification
    if method == "centroid":
        return defuzz_centroid(activations, mfs["ale"])
    elif method == "weighted_avg":
        return defuzz_weighted_average(activations)
    elif method == "max_membership":
        return defuzz_max_membership(activations)
    elif method == "COS":
        return defuzz_center_of_sums(activations, mfs["ale"])
    else:
        return defuzz_weighted_average(activations)


# 7) Tüm kombinasyonları test et
def run_combination(mfs, method, aggregation="min"):
    """Bir kombinasyon için sonuçları hesapla"""
    predictions = []
    for _, row in df.iterrows():
        pred = evaluate_row(row, mfs, method, aggregation)
        predictions.append(pred)

    mae = mean_absolute_error(df["ale"], predictions)
    rmse = np.sqrt(mean_squared_error(df["ale"], predictions))
    r2 = r2_score(df["ale"], predictions)

    return mae, rmse, r2, predictions

# 8) Tüm kombinasyonları çalıştır ve sonuçları karşılaştır
print("\n=== FUZZY LOGIC SİSTEM SONUÇLARI ===")
print(f"{'Model':<20} {'Method':<12} {'Agg':<5} {'MAE':<8} {'RMSE':<8} {'R²':<8}")
print("-" * 65)

all_results = []
mf_dict = {
    "Optimized_Tri": optimized_triangular,
    "Optimized_Gauss": optimized_gaussian,
    "Hybrid_Optimized": hybrid_optimized,
    "Optimized_Trap": optimized_trapezoidal
}

methods = ["centroid", "weighted_avg", "max_membership","COS"]
aggregations = ["min", "prod"]

best_result = None
best_score = float('inf')

for mf_name, mfs in mf_dict.items():
    for method in methods:
        for agg in aggregations:
            try:
                mae, rmse, r2, preds = run_combination(mfs, method, agg)

                print(f"{mf_name:<20} {method:<12} {agg:<5} {mae:<8.4f} {rmse:<8.4f} {r2:<8.4f}")

                all_results.append({
                    'model': mf_name,
                    'method': method,
                    'aggregation': agg,
                    'mae': mae,
                    'rmse': rmse,
                    'r2': r2,
                    'predictions': preds
                })

                # En iyi modeli takip et (MAE'ye göre)
                if mae < best_score:
                    best_score = mae
                    best_result = all_results[-1].copy()

            except Exception as e:
                print(f"{mf_name:<20} {method:<12} {agg:<5} ERROR: {str(e)[:20]}")

print(f"\n=== EN İYİ MODEL ===")
if best_result:
    print(f"Model: {best_result['model']}")
    print(f"Method: {best_result['method']}")
    print(f"Aggregation: {best_result['aggregation']}")
    print(f"MAE: {best_result['mae']:.4f}")
    print(f"RMSE: {best_result['rmse']:.4f}")
    print(f"R²: {best_result['r2']:.4f}")

# 9) Görselleştirme
if best_result:

    df_hatalar = df.copy()
    df_hatalar["tahmin"] = best_result["predictions"]
    df_hatalar["hata"] = df_hatalar["tahmin"] - df_hatalar["ale"]
    df_hatalar["mutlak_hata"] = np.abs(df_hatalar["hata"])

    # Hatalara göre sıralama (en büyük hata en üstte)
    df_hatalar_sorted = df_hatalar.sort_values("mutlak_hata", ascending=False)

    # En kötü 10 tahmini yazdır
    print("\n=== EN HATALI 10 TAHMİN ===")
    print(df_hatalar_sorted[["anchor_ratio", "trans_range", "node_density", "iterations", "ale", "tahmin", "hata", "mutlak_hata"]].head(20))

    plt.figure(figsize=(12, 8))

    # Gerçek vs Tahmin edilen değerler
    plt.subplot(2, 2, 1)
    plt.scatter(df["ale"], best_result['predictions'], alpha=0.7)
    plt.plot([df["ale"].min(), df["ale"].max()], [df["ale"].min(), df["ale"].max()], 'r--')
    plt.xlabel('Gerçek ALE')
    plt.ylabel('Tahmin Edilen ALE')
    plt.title('Gerçek vs Tahmin Edilen Değerler')
    plt.grid(True, alpha=0.3)

    # Hata dağılımı
    plt.subplot(2, 2, 2)
    errors = np.array(best_result['predictions']) - df["ale"].values
    plt.hist(errors, bins=20, alpha=0.7, edgecolor='black')
    plt.xlabel('Hata (Tahmin - Gerçek)')
    plt.ylabel('Frekans')
    plt.title('Hata Dağılımı')
    plt.grid(True, alpha=0.3)

    # Residual plot
    plt.subplot(2, 2, 3)
    plt.scatter(best_result['predictions'], errors, alpha=0.7)
    plt.axhline(y=0, color='r', linestyle='--')
    plt.xlabel('Tahmin Edilen ALE')
    plt.ylabel('Residual')
    plt.title('Residual Plot')
    plt.grid(True, alpha=0.3)

    # Model performansı karşılaştırması
    plt.subplot(2, 2, 4)
    mae_values = [r['mae'] for r in all_results[:10]]  # İlk 10 model
    model_names = [f"{r['model'][:8]}_{r['method'][:3]}" for r in all_results[:10]]
    plt.bar(range(len(mae_values)), mae_values)
    plt.xlabel('Model')
    plt.ylabel('MAE')
    plt.title('Model Performans Karşılaştırması')
    plt.xticks(range(len(model_names)), model_names, rotation=45)
    plt.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.show()

print(f"\n=== SONUÇ ÖZETİ ===")
print(f"Toplam {len(all_results)} farklı model kombinasyonu test edildi.")
print(f"En iyi model MAE: {best_score:.4f}")
print("Model veri setinizin özelliklerine göre optimize edilmiştir.")

# 🔧 Lineer Regresyon ile Eğimi Düzelt
from sklearn.linear_model import LinearRegression

y_true = df["ale"].values
y_pred = np.array(best_result["predictions"])

reg = LinearRegression().fit(y_pred.reshape(-1, 1), y_true)
y_pred_corrected = reg.predict(y_pred.reshape(-1, 1))

print("\n=== LINEER DÜZELTME SONRASI ===")
print("Eğim katsayısı:", reg.coef_[0])
print("Bias (kesişim):", reg.intercept_)
print("MAE:", mean_absolute_error(y_true, y_pred_corrected))
print("RMSE:", np.sqrt(mean_squared_error(y_true, y_pred_corrected)))